<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Call - ImproveCommunication</title>
    <link rel="stylesheet" href="../css/style.css">
    <script src="../js/config.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f8f9fa;
            color: #1a202c;
            height: 100vh;
            overflow: hidden;
        }
        
        .call-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .call-header {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
        }
        
        .call-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: white;
            color: #6366f1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
        }
        
        .call-details h2 {
            font-size: 20px;
            margin-bottom: 5px;
        }
        
        .call-details p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .call-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .control-btn {
            background: rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.1);
            color: #1a202c;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            background: rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .end-call-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border: none;
        }
        
        .call-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            position: relative;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }
        
        .loading-screen {
            text-align: center;
            max-width: 500px;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(99, 102, 241, 0.3);
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status-message {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .status-details {
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 30px;
        }
        
        .call-active {
            text-align: center;
            max-width: 600px;
            width: 100%;
        }
        
        .audio-visualizer {
            width: 300px;
            height: 150px;
            margin: 0 auto 40px;
            position: relative;
        }
        
        .wave {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
        }
        
        .wave-bar {
            position: absolute;
            bottom: 0;
            width: 4px;
            background: linear-gradient(to top, #6366f1, #8b5cf6);
            border-radius: 2px 2px 0 0;
            transform-origin: bottom;
            animation: wave 1.2s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { transform: scaleY(0.3); }
            50% { transform: scaleY(1); }
        }
        
        .connection-status {
            display: inline-block;
            padding: 10px 20px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 20px;
            font-size: 14px;
            margin-bottom: 30px;
        }
        
        .status-connected {
            background: rgba(34, 197, 94, 0.2);
        }
        
        .status-disconnected {
            background: rgba(239, 68, 68, 0.2);
        }
        
        .call-timer {
            font-size: 48px;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
            margin-bottom: 40px;
            color: #60a5fa;
            text-shadow: 0 2px 10px rgba(96, 165, 250, 0.3);
        }
        
        .mic-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }
        
        .mic-icon {
            width: 20px;
            height: 20px;
            background: #10b981;
            border-radius: 50%;
            position: relative;
            transition: background 0.3s;
        }
        
        .mic-icon.muted {
            background: #ef4444;
        }
        
        .mic-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }
        
        .pre-call-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
        }
        
        .start-call-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 30px;
            box-shadow: 0 6px 25px rgba(16, 185, 129, 0.3);
        }
        
        .start-call-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(16, 185, 129, 0.4);
        }
        
        .error-screen {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            margin-top: 30px;
        }
        
        .retry-btn {
            background: #6366f1;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: 600;
        }
        
        .incoming-call-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 40px;
            text-align: center;
        }
        
        .call-actions {
            display: flex;
            gap: 20px;
            margin-top: 40px;
        }
        
        .accept-call-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .reject-call-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Custom Scrollbar for Transcription - YouTube Style */
        #transcriptionMessages::-webkit-scrollbar {
            width: 6px;
        }
        
        #transcriptionMessages::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 10px;
        }
        
        #transcriptionMessages::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #6366f1, #8b5cf6);
            border-radius: 10px;
            transition: background 0.3s;
        }
        
        #transcriptionMessages::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #818cf8, #a78bfa);
        }
    </style>
</head>
<body>
    <div class="call-container">
        <!-- Call Header -->
        <div class="call-header" id="callHeader">
            <div class="call-info">
                <div class="avatar" id="partnerAvatar">?</div>
                <div class="call-details">
                    <h2 id="partnerName">Audio Call</h2>
                    <p id="callStatus" class="call-status">Ready to connect</p>
                </div>
            </div>
            <div class="call-controls">
                <div class="mic-indicator" id="micIndicator" style="display: none;">
                    <div class="mic-icon" id="micIcon"></div>
                    <span id="micStatus">Mic: On</span>
                </div>
                <button class="control-btn" onclick="toggleMute()" id="muteBtn">
                    <span id="muteIcon">üîä</span> <span id="muteText">Mute</span>
                </button>
                <button class="control-btn end-call-btn" onclick="endCall()" id="endCallBtn">
                    üìû End Call
                </button>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="call-content" id="callContent">
            <!-- Loading Screen -->
            <div class="loading-screen" id="loadingScreen" style="display: none;">
                <div class="loading-spinner"></div>
                <div class="status-message" id="statusMessage">Connecting to call...</div>
                <div class="status-details" id="statusDetails">Setting up WebRTC connection</div>
                <div class="connection-status" id="connectionStatus">üîÑ Initializing</div>
            </div>
            
            <!-- Active Call Screen -->
            <div class="call-active" id="callActive" style="display: none;">
                <div class="call-timer" id="callTimer">00:00</div>
                <div class="connection-status" id="activeStatus" style="margin-bottom: 20px;">
                    üü¢ Connected
                </div>
                
                <!-- Real-time Transcription Display - YouTube Music Lyrics Style -->
                <div id="transcriptionContainer" style="
                    background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
                    border: 1px solid rgba(99, 102, 241, 0.2);
                    border-radius: 16px;
                    padding: 28px;
                    max-width: 750px;
                    width: 90%;
                    height: 420px;
                    margin: 0 auto;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
                ">
                    <h3 style="
                        margin: 0 0 24px 0;
                        font-size: 20px;
                        opacity: 0.95;
                        text-align: center;
                        font-weight: 600;
                        color: #e2e8f0;
                        letter-spacing: 0.5px;
                    ">üí¨ Live Conversation</h3>
                    <div id="transcriptionMessages" style="
                        flex: 1;
                        overflow-y: auto;
                        overflow-x: hidden;
                        display: flex;
                        flex-direction: column;
                        gap: 4px;
                        padding: 0 8px 0 0;
                        scroll-behavior: smooth;
                        -webkit-overflow-scrolling: touch;
                    ">
                        <div style="
                            opacity: 0.5;
                            text-align: center;
                            font-size: 15px;
                            padding: 40px 20px;
                            color: #94a3b8;
                            font-style: italic;
                        ">Transcription will appear here as you speak...</div>
                    </div>
                </div>
                
                <div style="opacity: 0.7; margin-top: 25px; font-size: 14px;">
                    üé§ Speak naturally into your microphone
                </div>
            </div>
            
            <!-- Pre-call Screen -->
            <div class="pre-call-screen" id="preCallScreen">
                <h1 style="font-size: 48px; margin-bottom: 20px;">üé§</h1>
                <h1 style="font-size: 36px; margin-bottom: 20px;">Audio Call</h1>
                <p style="font-size: 18px; opacity: 0.8; margin-bottom: 30px;" id="preCallMessage">
                    Waiting to connect with your partner
                </p>
                <button class="start-call-btn" onclick="initializeCall()" id="startCallBtn">
                    Start Audio Call
                </button>
            </div>
            
            <!-- Incoming Call Screen -->
            <div class="incoming-call-screen" id="incomingCallScreen" style="display: none;">
                <div class="avatar" id="callerAvatar" style="width: 100px; height: 100px; font-size: 40px; margin-bottom: 30px;">?</div>
                <h1 style="font-size: 36px; margin-bottom: 20px;">Incoming Call</h1>
                <p style="font-size: 24px; margin-bottom: 10px;" id="callerName">Loading...</p>
                <p style="font-size: 18px; opacity: 0.8; margin-bottom: 40px;">is calling you</p>
                <div class="call-actions">
                    <button class="accept-call-btn" onclick="acceptIncomingCall()">
                        üìû Accept
                    </button>
                    <button class="reject-call-btn" onclick="rejectIncomingCall()">
                        ‚ùå Reject
                    </button>
                </div>
            </div>
            
            <!-- Error Screen -->
            <div class="error-screen" id="errorScreen" style="display: none;">
                <h3 style="color: #ef4444; margin-bottom: 15px;">Connection Failed</h3>
                <p id="errorMessage" style="margin-bottom: 20px;"></p>
                <button class="retry-btn" onclick="retryConnection()">Retry Connection</button>
                <button class="retry-btn" onclick="window.location.href='users.html'" style="margin-left: 10px; background: #6b7280;">Go Back</button>
            </div>
        </div>
        
        <!-- Audio Elements -->
        <audio id="remoteAudio" autoplay playsinline></audio>
        <audio id="localAudio" muted playsinline></audio>
    </div>

    <script>
        // Global state
        let peerConnection = null;
        let localStream = null;
        let remoteStream = null;
        let ws = null;
        let callTimer = null;
        let callStartTime = null;
        let isMuted = false;
        let isLocalAudioActive = false;
        let currentUser = null;
        let partnerUser = null;
        let callId = null;
        let isCaller = false;
        let incomingCallData = null;
        let callActive = false;
        
        // WebRTC Configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                {
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                {
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: 'all'
        };
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Page loaded - Initializing call system');
            
            // Check authentication
            await checkAuthentication();
            
            // Get call ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            callId = urlParams.get('callId');
            
            if (callId) {
                console.log('üìû Call ID from URL:', callId);
                await fetchCallDetails();
            } else {
                console.log('‚ö†Ô∏è No call ID in URL - waiting for incoming call');
                updatePreCallMessage('Waiting for incoming call or start a new one');
                // Connect to WebSocket to receive notifications
                connectWebSocket();
            }
        });
        
        // Check authentication
        async function checkAuthentication() {
            try {
                const token = localStorage.getItem('token');
                const userStr = localStorage.getItem('user');
                
                if (!token || !userStr) {
                    window.location.href = 'login.html';
                    return;
                }
                
                currentUser = JSON.parse(userStr);
                console.log('‚úÖ Authenticated as:', currentUser.name);
                
            } catch (error) {
                console.error('‚ùå Authentication error:', error);
                window.location.href = 'login.html';
            }
        }
        
        // Connect to WebSocket for notifications
        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/ws/${currentUser.id}`;
                
                console.log('üîå Connecting to WebSocket:', wsUrl);
                
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('‚úÖ WebSocket connected for notifications');
                    updateStatus('Connected - Ready for calls', '‚úÖ');
                    
                    // Start ping to keep connection alive
                    setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 30000);
                };
                
                ws.onmessage = handleWebSocketMessage;
                
                ws.onerror = (error) => {
                    console.error('‚ùå WebSocket error:', error);
                };
                
                ws.onclose = () => {
                    console.log('üîå WebSocket closed');
                    setTimeout(connectWebSocket, 3000); // Reconnect after 3 seconds
                };
                
            } catch (error) {
                console.error('‚ùå Error connecting to WebSocket:', error);
            }
        }
        
        // Handle WebSocket messages
        function handleWebSocketMessage(event) {
            try {
                const data = JSON.parse(event.data);
                console.log('üì® WebSocket:', data.type);
                
                switch(data.type) {
                    case 'call_invitation':
                        handleIncomingCall(data);
                        break;
                        
                    case 'call_accepted':
                        console.log('‚úÖ Call accepted by partner');
                        if (isCaller) {
                            updateStatus('Partner joined! Starting call...', 'üéâ');
                            setTimeout(startWebRTCCall, 1000);
                        }
                        break;
                        
                    case 'call_started':
                        console.log('‚úÖ Call started - you are the receiver');
                        isCaller = false;
                        partnerUser = { id: data.partner_id };
                        updateStatus('Call started. Connecting...', 'üìû');
                        setTimeout(startWebRTCCall, 1000);
                        break;
                        
                    case 'webrtc_signal':
                        handleWebRTCSignal(data.signal);
                        break;
                        
                    case 'call_ended':
                        console.log('üìû Call ended by partner');
                        alert('Call ended by partner');
                        endCall();
                        break;
                        
                    case 'pong':
                        // Keep-alive
                        break;
                        
                    default:
                        console.log('üì® Other message:', data);
                }
            } catch (error) {
                console.error('‚ùå Error handling WebSocket message:', error);
            }
        }
        
        // Handle incoming call
        function handleIncomingCall(data) {
            console.log('üìû Incoming call:', data);
            
            incomingCallData = data;
            
            // Show incoming call screen
            document.getElementById('preCallScreen').style.display = 'none';
            document.getElementById('incomingCallScreen').style.display = 'flex';
            
            // Update UI
            document.getElementById('callerName').textContent = 'User';
            document.getElementById('callerAvatar').textContent = '?';
            
            // Fetch caller details
            fetchCallerDetails(data.from_user);
        }
        
        // Fetch caller details
        async function fetchCallerDetails(callerId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE_URL}/api/users/${callerId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (response.ok) {
                    const caller = await response.json();
                    document.getElementById('callerName').textContent = caller.name;
                    document.getElementById('callerAvatar').textContent = caller.name.charAt(0).toUpperCase();
                }
            } catch (error) {
                console.error('‚ùå Error fetching caller:', error);
            }
        }
        
        // Accept incoming call
        async function acceptIncomingCall() {
            if (!incomingCallData) return;
            
            console.log('‚úÖ Accepting incoming call');
            
            // Send acceptance via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'accept_call_invitation',
                    invitation_id: incomingCallData.invitation_id
                }));
            }
            
            // Hide incoming call screen
            document.getElementById('incomingCallScreen').style.display = 'none';
            
            // Set up call
            callId = incomingCallData.call_id;
            isCaller = false;
            
            // Show loading screen
            document.getElementById('loadingScreen').style.display = 'block';
            updateStatus('Accepting call...', 'üìû');
            
            // Wait a moment then start WebRTC
            setTimeout(startWebRTCCall, 1000);
        }
        
        // Reject incoming call
        function rejectIncomingCall() {
            if (!incomingCallData) return;
            
            console.log('‚ùå Rejecting incoming call');
            
            // Send rejection via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'reject_call_invitation',
                    invitation_id: incomingCallData.invitation_id,
                    call_id: incomingCallData.call_id,
                    from_user_id: incomingCallData.from_user_id
                }));
            }
            
            // Clean up state
            incomingCallData = null;
            callId = null;
            
            // Hide incoming call screen and return to dashboard
            document.getElementById('incomingCallScreen').style.display = 'none';
            
            // Show message and redirect to dashboard
            console.log('üîô Redirecting to dashboard...');
            setTimeout(() => {
                window.location.href = 'dashboard.html';
            }, 500);
        }
        
        // Fetch call details from backend
        async function fetchCallDetails() {
            try {
                updateStatus('Loading call details...', 'üîÑ');
                
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE_URL}/api/calls/my-calls`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const calls = await response.json();
                const call = calls.find(c => c.id === callId);
                
                if (!call) {
                    showError('Call not found. It may have been ended.', true);
                    return;
                }
                
                // Determine if we're caller or receiver
                isCaller = call.caller_id === currentUser.id;
                const partnerId = isCaller ? call.receiver_id : call.caller_id;
                
                // Fetch partner details
                await fetchPartnerDetails(partnerId);
                
                // Update UI
                updateCallUI();
                
                // Connect to WebSocket
                connectWebSocket();
                
            } catch (error) {
                console.error('‚ùå Error fetching call details:', error);
                showError('Failed to load call details. Please try again.', false);
            }
        }
        
        // Fetch partner details
        async function fetchPartnerDetails(partnerId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE_URL}/api/users/${partnerId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (response.ok) {
                    partnerUser = await response.json();
                    console.log('‚úÖ Partner:', partnerUser.name);
                } else {
                    console.warn('‚ö†Ô∏è Could not fetch partner details');
                    partnerUser = { id: partnerId, name: 'Partner' };
                }
            } catch (error) {
                console.error('‚ùå Error fetching partner:', error);
                partnerUser = { id: partnerId, name: 'Partner' };
            }
        }
        
        // Update call UI
        function updateCallUI() {
            if (partnerUser) {
                document.getElementById('partnerName').textContent = partnerUser.name;
                document.getElementById('partnerAvatar').textContent = partnerUser.name.charAt(0).toUpperCase();
            }
            
            if (isCaller) {
                document.getElementById('preCallMessage').textContent = `Calling ${partnerUser?.name || 'Partner'}...`;
                document.getElementById('startCallBtn').textContent = 'Start Call';
            } else {
                document.getElementById('preCallMessage').textContent = `Waiting for call from ${partnerUser?.name || 'Partner'}...`;
                document.getElementById('startCallBtn').textContent = 'Join Call';
            }
        }
        
        // Initialize call (caller only)
        async function initializeCall() {
            console.log('üé¨ Initializing call as caller...');
            
            if (!isCaller) {
                console.log('‚ö†Ô∏è Only caller can initialize call');
                return;
            }
            
            // Send call invitation
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'send_call_invitation',
                    to_user: partnerUser.id,
                    call_id: callId,
                    call_data: {
                        caller_id: currentUser.id,
                        caller_name: currentUser.name
                    }
                }));
            }
            
            // Show loading screen
            document.getElementById('preCallScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'block';
            updateStatus('Calling partner...', 'üìû');
        }
        
        // Start WebRTC call
        async function startWebRTCCall() {
            console.log('üé¨ Starting WebRTC call...');
            console.log('Role:', isCaller ? 'Caller' : 'Receiver');
            
            try {
                // Get microphone access
                await getLocalStream();
                
                // Initialize WebRTC
                await initializeWebRTC();
                
                // If caller, create offer after delay
                if (isCaller) {
                    setTimeout(() => createOffer(), 1500);
                }
                
                updateStatus('Setting up audio connection...', 'üé§');
                
            } catch (error) {
                console.error('‚ùå Failed to start call:', error);
                showError(`Failed to start call: ${error.message}`, false);
            }
        }
        
        // Get local microphone stream
        async function getLocalStream() {
            updateStatus('Requesting microphone...', 'üé§');
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        channelCount: 1,
                        sampleRate: 48000,
                        sampleSize: 16
                    },
                    video: false
                });
                
                console.log('‚úÖ Microphone access granted');
                updateStatus('Microphone ready', '‚úÖ');
                
                // Play local audio (muted) for monitoring
                const localAudio = document.getElementById('localAudio');
                if (localAudio) {
                    localAudio.srcObject = localStream;
                }
                
                // Show mic indicator
                document.getElementById('micIndicator').style.display = 'flex';
                updateMicStatus();
                
            } catch (error) {
                console.error('‚ùå Microphone access denied:', error);
                throw new Error('Microphone access is required. Please allow microphone permissions and refresh the page.');
            }
        }
        
        // Initialize WebRTC peer connection
        async function initializeWebRTC() {
            console.log('üîÑ Creating peer connection');
            
            try {
                peerConnection = new RTCPeerConnection(rtcConfig);
                
                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    console.log(`üéµ Added ${track.kind} track:`, track.id);
                });
                
                // Handle incoming audio
                peerConnection.ontrack = (event) => {
                    console.log('üéµ Received remote track');
                    remoteStream = event.streams[0];
                    const remoteAudio = document.getElementById('remoteAudio');
                    
                    if (remoteAudio.srcObject !== remoteStream) {
                        remoteAudio.srcObject = remoteStream;
                        console.log('‚úÖ Remote audio connected');
                        
                        // Show active call screen
                        showActiveCallScreen();
                        
                        // Start timer
                        startCallTimer();
                        
                        // Mark user as joined
                        markUserJoined();
                        
                        // Update status
                        updateStatus('Call connected!', 'üéâ');
                    }
                };
                
                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate && ws && ws.readyState === WebSocket.OPEN && partnerUser) {
                        console.log('üßä ICE candidate generated');
                        sendWebRTCSignal({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            to_user_id: partnerUser.id,
                            call_id: callId
                        });
                    } else if (!event.candidate) {
                        console.log('‚úÖ ICE gathering complete');
                    }
                };
                
                // Monitor connection state
                peerConnection.onconnectionstatechange = () => {
                    const state = peerConnection.connectionState;
                    console.log('üîó Connection state:', state);
                    
                    switch(state) {
                        case 'connected':
                            updateStatus('Call connected!', 'üéâ');
                            callActive = true;
                            break;
                        case 'connecting':
                            updateStatus('Connecting...', 'üîÑ');
                            break;
                        case 'disconnected':
                            updateStatus('Disconnected', '‚ö†Ô∏è');
                            callActive = false;
                            break;
                        case 'failed':
                            updateStatus('Connection failed', '‚ùå');
                            callActive = false;
                            attemptReconnect();
                            break;
                        case 'closed':
                            console.log('Connection closed');
                            callActive = false;
                            break;
                    }
                };
                
                // Monitor ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('üßä ICE connection state:', peerConnection.iceConnectionState);
                };
                
                console.log('‚úÖ Peer connection initialized');
                
            } catch (error) {
                console.error('‚ùå Error initializing WebRTC:', error);
                throw error;
            }
        }
        
        // Create WebRTC offer
        async function createOffer() {
            try {
                console.log('üìû Creating offer...');
                updateStatus('Establishing connection...', 'üîÑ');
                
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: false
                });
                
                await peerConnection.setLocalDescription(offer);
                console.log('‚úÖ Local description set');
                
                sendWebRTCSignal({
                    type: 'offer',
                    offer: offer,
                    to_user_id: partnerUser.id,
                    call_id: callId
                });
                
                console.log('‚úÖ Offer sent');
                
            } catch (error) {
                console.error('‚ùå Error creating offer:', error);
                showError('Failed to establish connection. Please try again.', false);
            }
        }
        
        // Handle incoming WebRTC signals
        async function handleWebRTCSignal(signal) {
            console.log('üîß Handling signal:', signal.type);
            
            try {
                if (!peerConnection) {
                    console.error('‚ùå No peer connection');
                    return;
                }
                
                switch(signal.type) {
                    case 'offer':
                        console.log('üì• Received offer');
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.offer));
                        
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        sendWebRTCSignal({
                            type: 'answer',
                            answer: answer,
                            to_user_id: signal.from_user || partnerUser.id,
                            call_id: signal.call_id
                        });
                        
                        console.log('‚úÖ Answer sent');
                        break;
                        
                    case 'answer':
                        console.log('üì• Received answer');
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.answer));
                        break;
                        
                    case 'ice-candidate':
                        console.log('üßä Received ICE candidate');
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Failed to add ICE candidate:', e);
                        }
                        break;
                }
                
            } catch (error) {
                console.error('‚ùå Error handling signal:', error);
            }
        }
        
        // Send WebRTC signal
        function sendWebRTCSignal(signal) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'webrtc_signal',
                    signal: signal
                }));
            } else {
                console.error('‚ùå WebSocket not connected');
            }
        }
        
        // Toggle mute
        function toggleMute() {
            if (!localStream) {
                console.error('‚ùå No local stream to mute');
                return;
            }
            
            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length > 0) {
                // Get current state
                const currentlyEnabled = audioTracks[0].enabled;
                
                // Toggle it
                audioTracks[0].enabled = !currentlyEnabled;
                isMuted = !audioTracks[0].enabled;
                
                console.log(`üé§ Audio track enabled: ${audioTracks[0].enabled}, isMuted: ${isMuted}`);
                
                // Update UI
                document.getElementById('muteIcon').textContent = isMuted ? 'üîá' : 'üîä';
                document.getElementById('muteText').textContent = isMuted ? 'Unmute' : 'Mute';
                
                // Update mic indicator
                const micIcon = document.getElementById('micIcon');
                const micStatus = document.getElementById('micStatus');
                
                if (isMuted) {
                    micIcon.classList.add('muted');
                    micStatus.textContent = 'Mic: Off';
                } else {
                    micIcon.classList.remove('muted');
                    micStatus.textContent = 'Mic: On';
                }
                
                console.log(isMuted ? 'üîá Microphone MUTED' : 'üîä Microphone UNMUTED');
            } else {
                console.error('‚ùå No audio tracks found');
            }
        }
        
        // Update mic status display
        function updateMicStatus() {
            if (!localStream) return;
            
            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length > 0) {
                isMuted = !audioTracks[0].enabled;
                
                const micIcon = document.getElementById('micIcon');
                const micStatus = document.getElementById('micStatus');
                
                if (isMuted) {
                    micIcon.classList.add('muted');
                    micStatus.textContent = 'Mic: Off';
                } else {
                    micIcon.classList.remove('muted');
                    micStatus.textContent = 'Mic: On';
                }
            }
        }
        
        // Show active call screen
        function showActiveCallScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('callActive').style.display = 'block';
            document.getElementById('callStatus').textContent = 'In call';
            document.getElementById('endCallBtn').style.display = 'flex';
            
            // Start the call timer immediately
            startCallTimer();
            
            console.log('‚úÖ Call screen active, timer started');
        }
        
        // Create audio visualizer
        function createAudioVisualizer() {
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 40; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                bar.style.left = `${i * 8}px`;
                bar.style.animationDelay = `${i * 0.05}s`;
                visualizer.appendChild(bar);
            }
        }
        
        // Start call timer
        function startCallTimer() {
            callStartTime = Date.now();
            
            callTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('callTimer').textContent = `${minutes}:${seconds}`;
            }, 1000);
        }
        
        // Mark user as joined
        async function markUserJoined() {
            try {
                const token = localStorage.getItem('token');
                await fetch(`${API_BASE_URL}/api/calls/mark-joined?call_id=${callId}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                console.log('‚úÖ Marked as joined');
            } catch (error) {
                console.error('‚ùå Error marking joined:', error);
            }
        }
        
        // End call
        async function endCall() {
            console.log('üìû Ending call...');
            
            // Stop timer
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
            
            // Send call end signal
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'end_call',
                    call_id: callId
                }));
            }
            
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Hide mic indicator
            document.getElementById('micIndicator').style.display = 'none';
            
            // Save call data
            if (callStartTime) {
                const duration = Math.floor((Date.now() - callStartTime) / 1000);
                await saveCallData(duration);
            }
            
            // Redirect to results
            setTimeout(() => {
                window.location.href = `call-results-new.html?callId=${callId}`;
            }, 1000);
        }
        
        // Save call data
        async function saveCallData(duration) {
            try {
                const token = localStorage.getItem('token');
                await fetch(`${API_BASE_URL}/api/calls/end`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        call_id: callId,
                        duration_seconds: duration
                    })
                });
                console.log('‚úÖ Call data saved');
            } catch (error) {
                console.error('‚ùå Error saving call data:', error);
            }
        }
        
        // Update status
        function updateStatus(message, emoji = '') {
            const statusMessage = document.getElementById('statusMessage');
            const statusDetails = document.getElementById('statusDetails');
            const connectionStatus = document.getElementById('connectionStatus');
            const callStatus = document.getElementById('callStatus');
            
            if (statusMessage) statusMessage.textContent = message;
            if (statusDetails) statusDetails.textContent = emoji ? `${emoji} ${message}` : message;
            if (connectionStatus) connectionStatus.textContent = emoji ? `${emoji} ${message}` : message;
            if (callStatus && !callActive) callStatus.textContent = message;
        }
        
        // Update pre-call message
        function updatePreCallMessage(message) {
            const element = document.getElementById('preCallMessage');
            if (element) element.textContent = message;
        }
        
        // Show error
        function showError(message, redirect = false) {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('preCallScreen').style.display = 'none';
            document.getElementById('errorScreen').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
            
            console.error('‚ùå Error:', message);
            
            if (redirect) {
                setTimeout(() => window.location.href = 'users.html', 3000);
            }
        }
        
        // Attempt reconnect
        function attemptReconnect() {
            console.log('üîÑ Attempting reconnect...');
            setTimeout(() => {
                if (peerConnection && peerConnection.connectionState === 'failed') {
                    console.log('üîÑ Reinitializing WebRTC...');
                    initializeWebRTC().catch(console.error);
                }
            }, 2000);
        }
        
        // Retry connection
        function retryConnection() {
            console.log('üîÑ Retrying connection...');
            startWebRTCCall();
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', (e) => {
            if (callActive) {
                e.preventDefault();
                e.returnValue = 'You have an active call. Are you sure you want to leave?';
                endCall();
            }
        });
        
        // ============================================
        // REAL-TIME TRANSCRIPTION FUNCTIONALITY
        // ============================================
        
        let recognition = null;
        let isTranscribing = false;
        
        // Initialize Speech Recognition
        function initializeSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('‚ö†Ô∏è Speech recognition not supported in this browser');
                return;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            let finalTranscript = '';
            
            recognition.onstart = () => {
                console.log('üé§ Speech recognition started');
                isTranscribing = true;
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                        // Save and broadcast transcription
                        if (transcript.trim().length > 0) {
                            saveAndBroadcastTranscription(transcript.trim());
                        }
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Show interim results in UI (optional)
                if (interimTranscript.length > 0) {
                    console.log('üìù Interim:', interimTranscript);
                }
            };
            
            recognition.onerror = (event) => {
                console.error('‚ùå Speech recognition error:', event.error);
                if (event.error === 'no-speech') {
                    // Automatically restart
                    setTimeout(() => {
                        if (callActive && !isMuted) {
                            recognition.start();
                        }
                    }, 1000);
                }
            };
            
            recognition.onend = () => {
                console.log('üé§ Speech recognition ended');
                isTranscribing = false;
                
                // Automatically restart if call is still active and not muted
                if (callActive && !isMuted) {
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.log('‚ö†Ô∏è Could not restart recognition:', e);
                        }
                    }, 500);
                }
            };
        }
        
        // Start transcription
        function startTranscription() {
            if (!recognition) {
                initializeSpeechRecognition();
            }
            
            if (recognition && !isTranscribing && !isMuted) {
                try {
                    recognition.start();
                    console.log('‚úÖ Transcription started');
                } catch (e) {
                    console.log('‚ö†Ô∏è Transcription already running');
                }
            }
        }
        
        // Stop transcription
        function stopTranscription() {
            if (recognition && isTranscribing) {
                recognition.stop();
                console.log('üõë Transcription stopped');
            }
        }
        
        // Save and broadcast transcription
        async function saveAndBroadcastTranscription(text) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE_URL}/api/calls/save-transcription?call_id=${callId}&text=${encodeURIComponent(text)}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    console.log('‚úÖ Transcription saved:', text);
                    
                    // Display in UI immediately (sender side)
                    const role = isCaller ? 'caller' : 'receiver';
                    displayTranscription(role, text, currentUser.name);
                } else {
                    console.error('‚ùå Failed to save transcription');
                }
            } catch (error) {
                console.error('‚ùå Error saving transcription:', error);
            }
        }
        
        // Display transcription in UI
        let userIsManuallyScrolling = false;
        let scrollTimeout = null;
        
        function displayTranscription(speaker, text, speakerName) {
            const messagesContainer = document.getElementById('transcriptionMessages');
            if (!messagesContainer) return;
            
            // Remove placeholder if exists
            const placeholder = messagesContainer.querySelector('[style*="opacity: 0.5"]');
            if (placeholder) {
                placeholder.remove();
            }
            
            // Determine if it's the current user
            const isCurrentUser = (speaker === 'caller' && isCaller) || (speaker === 'receiver' && !isCaller);
            const displayName = isCurrentUser ? 'You' : (partnerUser?.name || 'Partner');
            
            // YouTube Music Lyrics Style - Clean and Simple
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                padding: 12px 20px;
                margin-bottom: 8px;
                border-left: 3px solid ${isCurrentUser ? '#6366f1' : '#8b5cf6'};
                background: ${isCurrentUser ? 'rgba(99, 102, 241, 0.15)' : 'rgba(139, 92, 246, 0.15)'};
                border-radius: 6px;
                transition: all 0.3s ease;
            `;
            
            // On hover, make it more prominent
            messageDiv.onmouseenter = function() {
                this.style.background = isCurrentUser ? 'rgba(99, 102, 241, 0.25)' : 'rgba(139, 92, 246, 0.25)';
                this.style.transform = 'translateX(5px)';
            };
            messageDiv.onmouseleave = function() {
                this.style.background = isCurrentUser ? 'rgba(99, 102, 241, 0.15)' : 'rgba(139, 92, 246, 0.15)';
                this.style.transform = 'translateX(0)';
            };
            
            messageDiv.innerHTML = `
                <div style="
                    font-weight: 700;
                    font-size: 13px;
                    color: ${isCurrentUser ? '#818cf8' : '#a78bfa'};
                    margin-bottom: 6px;
                    letter-spacing: 0.5px;
                    text-transform: uppercase;
                ">${displayName}</div>
                <div style="
                    font-size: 16px;
                    line-height: 1.6;
                    color: #ffffff;
                    font-weight: 400;
                ">${text}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            
            // Auto-scroll to bottom ONLY if user is not manually scrolling
            if (!userIsManuallyScrolling) {
                const container = document.getElementById('transcriptionContainer');
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
            }
        }
        
        // Detect manual scrolling
        (function setupScrollDetection() {
            setTimeout(() => {
                const container = document.getElementById('transcriptionContainer');
                if (container) {
                    container.addEventListener('scroll', function() {
                        // Check if user scrolled up (not at bottom)
                        const isAtBottom = this.scrollHeight - this.scrollTop <= this.clientHeight + 50;
                        userIsManuallyScrolling = !isAtBottom;
                        
                        // If user scrolls to bottom, resume auto-scroll
                        if (isAtBottom) {
                            userIsManuallyScrolling = false;
                        }
                        
                        // Clear previous timeout
                        if (scrollTimeout) clearTimeout(scrollTimeout);
                        
                        // After 3 seconds of no scrolling, resume auto-scroll
                        scrollTimeout = setTimeout(() => {
                            userIsManuallyScrolling = false;
                        }, 3000);
                    });
                    
                    console.log('‚úÖ Scroll detection enabled');
                }
            }, 2000);
        })();
        
        // Handle incoming transcription from WebSocket
        function handleIncomingTranscription(data) {
            console.log('üìù Received transcription:', data);
            
            // Only display if it's from the partner (not echoing our own)
            const isFromPartner = data.speaker_id !== currentUser.id;
            
            if (isFromPartner) {
                displayTranscription(data.speaker_role, data.text, partnerUser?.name);
            }
        }
        
        // Modified showActiveCallScreen to start transcription
        const originalShowActiveCallScreen = showActiveCallScreen;
        showActiveCallScreen = function() {
            originalShowActiveCallScreen();
            
            // Start transcription after a short delay
            setTimeout(() => {
                startTranscription();
            }, 2000);
        };
        
        // Modified toggleMute to control transcription
        const originalToggleMute = toggleMute;
        toggleMute = function() {
            originalToggleMute();
            
            // Control transcription based on mute status
            if (isMuted) {
                stopTranscription();
            } else if (callActive) {
                startTranscription();
            }
        };
        
        // Modified handleWebSocketMessage to handle transcription
        const originalHandleWebSocketMessage = handleWebSocketMessage;
        handleWebSocketMessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                
                // Handle transcription messages
                if (data.type === 'transcription') {
                    handleIncomingTranscription(data);
                    return;
                }
                
                // Call original handler for other message types
                originalHandleWebSocketMessage(event);
            } catch (error) {
                console.error('‚ùå Error in message handler:', error);
            }
        };
        
        // ============================================
        // END TRANSCRIPTION FUNCTIONALITY
        // ============================================
        
        // Expose functions globally
        window.toggleMute = toggleMute;
        window.endCall = endCall;
        window.initializeCall = initializeCall;
        window.acceptIncomingCall = acceptIncomingCall;
        window.rejectIncomingCall = rejectIncomingCall;
        window.retryConnection = retryConnection;
    </script>
</body>
</html>